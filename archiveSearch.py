#!/usr/bin/python
"""
ArchiveSearch
This tool allows you to perform a few operations on the set of archives
generated by the omons build process.  It will perform these operations on
either tars (tgz) or RPM files (provide your system has the rpm tools
installed).
The tool has these subcommands:
 find - search to find which rpm/tar contains a given string in filename
      archivesearch.py find filename
          (search all archives in this dir for filename)
      archivesearch.py find -d dirname [-d anotherdir] filename [filename]
          (search all archives in dirname for filname)
      archivesearch.py find -a archive [-a anotherarch] filename [filename]
          (search archive for filename)
 dups - find files which are repeated in tars (or rpms) in a directory
      archivesearch.py dups directory [directory]
          (flag and fail if more than one archive in the directories produces
          the same file)
 list - list all filenames in a give directory or tar/rpm
      archivesearch.py list -d dirname [-d anotherdir]
          (list contents of all archives in dirname(s))
      archivesearch.py list -a archive [-a anotherarch]
          (list contents of specified archive(s))
 bad - find instances of forbidden files in archives (man pages, .la files)
      archivesearch.py bad directory [directory]
          (flag and fail if any of a set of files is present.)
 buildcheck - do both dups and bad commands
"""
import argparse
import tarfile
import os
import sys
import commands

def getFilenamesFromArchive(tar):
    """Returns list of files stored in the given tar or rpm file."""
    if tar.endswith('.tgz'):
        tarlist = getFilenamesFromTar(tar)
    else:
        tarlist = getFilenamesFromRpm(tar)
    return tarlist

def getFilenamesFromTar(tarname):
    """Returns list of files stored in the given tar file."""
    names = list()
    try:
        tar = tarfile.open("%s" % (tarname))
        names = tar.getnames()
        tar.close()
    except Exception as e:
        print >>sys.stderr, "failed to process %s" % tarname, e
    return names

def getFilenamesFromRpm(rpmname):
    """Returns list of files stored in the given rpm file."""
    names = list()
    try:
        names = commands.getoutput("rpm -qp --queryformat '[%%{FILENAMES}\\n]' %s"%rpmname).splitlines()
    except Exception as e:
        print >>sys.stderr, "failed to process %s" % rpmname, e
    return names

def isThisADirectory(dirname, setOfFiles):
    """Searches a file list to see if the given dir name is a subset of some
    other path name - thus indicating it is a tar/rpm entry that is just a
    directory and not a file.
    """
    # special case - if it ends with a '/' it is a directory
    if dirname.endswith('/'):
        return True

    for f in setOfFiles:
        if f.startswith(dirname) and f != dirname:
            return True
    return False

def getFilenamesFromDirs(dirs):
    """Walks a list of directories and returns a list of all of the .tgz and
    .rpm files contained therein."""
    archives = list()
    for dirname in dirs:
        # make sure we have the trailing slash
        if not dirname.endswith('/'): dirname = dirname + '/'

        # you can get similar results with the glob module, but I want
        # full paths and didn't see how to do that.
        dirList=os.listdir(dirname)
        for name in dirList:
            if name.endswith('.tgz') or name.endswith('.rpm'):
                archives.append('%s%s' % (dirname, name))
    return archives

def searchInArchives(tars, filename = None):
    """Searches through the files contained in each archive in the given list
    for a filename containing the given filename string.

    Filename can be a substring and does not need to be an exact match.  If no
    filename is specified, all files in all archives are listed.
    """
    for tar in tars:
        if not filename:
            print "processing %s" % tar
            print "----------------------------------------"

        tarlist = getFilenamesFromArchive(tar)

        for t in tarlist:
            if not filename:
                print t
            elif filename in t:
                print "%s in %s" % (t, tar)

def findInArchives(args):
    """Performs the find operation from the command line."""
    # -a and -d are forced to be mutually exclusive by argparse
    if args.directory:
        tars = getFilenamesFromDirs(args.directory)

    if args.archive:
        tars = args.archive

    # loop through each file spec'd on the cmd line
    for f in args.filename:
        searchInArchives(tars, f)
    return False

def dupsInArchives(args):
    """Performs the dups operation from the command line."""
    unique = dict() # the set we'll use to store the gathered list of files

    tars = getFilenamesFromDirs(args.directories)
    dups = False
    for tar in tars:
        # special case directory structure.  It should only contain empty
        # directories
        if 'directory_structure' in tar: continue

        tarlist = getFilenamesFromArchive(tar)
        for itemname in tarlist:
            if itemname in unique:
                # special case tests here
                # we publish the fpga code in several versions for each build.
                # This allows us to not have a separate product build for each
                # board (which generally is only an fpga change)
                if 'phoenix_pkg' in tar and 'phoenix_pkg' in unique[itemname]: continue
                if 'maxwell_fpga_bin' in tar and 'phoenix_pkg' in unique[itemname]: continue
                if 'phoenix_pkg' in tar and 'maxwell_fpga_bin' in unique[itemname]: continue
                # omons-lsp needs to be pulled in to maxwell for the snapshot
                # driver.  Someone with more time could go and clean up the
                # packaging for omons-lsp to make it more selective on maxwell,
                # but this will do for now
                if 'omons-lsp' in tar and 'ti-sdk' in unique[itemname]: continue
                if 'ti-sdk' in tar and 'omons-lsp' in unique[itemname]: continue
                if 'omons-lsp' in tar and 'ti-kernel' in unique[itemname]: continue
                if 'ti-kernel' in tar and 'omons-lsp' in unique[itemname]: continue
                # another special case for the kernel stuff.  TODO get these all
                # cleaned up!  Here's the plan.  All packages which create
                # kernel modules (which, as far as I know at the moment, include
                # omons-lsp, ti-kernel, and ti-sdk) create depmod files.  These
                # are currently packaged in the dev pkg by all of them which
                # causes conflicts.  They should not be packaged at all (they
                # may be installed during the install step to get the nfs mount
                # working correctly, however).  Once these are removed, they
                # depmod step needs to be added toward the end of the build
                # process after all of the packages are installed.  A first step
                # at this was done for centaurus builds by dan Franke.  (see
                # crucible review OP-5591 - om_v2_product.xml)  The depmod
                # command needs to be added to two spots in the
                # /opt/omtools/ombuild/om_v[12]_product.xml file; once in the
                # rootfs.base section  (this one is already present).  The
                # second place is in the fwupdate section which is not present
                # (and which will require a tools release for v1 fw at least.)
                # Once this tool release is done (hopefully by end of Feb 2013)
                # we should be able to remove the /lib/modules/*/* stuff from
                # these dev packages.
                # in the meantime, we'll not flag these so we can pass the
                # build.
                if itemname.startswith('lib/modules') and '/modules' in itemname:
                        continue


                # don't report non-empty directories
                if isThisADirectory(itemname, tarlist): continue

                print >>sys.stderr, "Found a dup: %s was in %s and %s" % (itemname, tar, unique[itemname])
                dups = True
            unique[itemname] = tar
    return dups

def listArchives(args):
    """Performs the list operation from the command line."""
    # -a and -d are forced to be mutually exclusive by argparse
    if args.directory:
        tars = getFilenamesFromDirs(args.directory)

    if args.archive:
        tars = args.archive

    # don't specify a name to search for - this lists all files
    searchInArchives(tars)
    return False

def forbiddenInArchives(args):
    """Performs the bad operation from the command line."""
    forbiddenInDev = ['.la', '.pc']
    forbiddenInAll = ['.h', '.a']
    forbiddenInAll.extend(forbiddenInDev) # if you can't have it in a dev
                                          # package, you can't put it on the
                                          # camera

    tars = getFilenamesFromDirs(args.directories)
    bad = False
    for tar in tars:
        # pick which set is disallowed for this package
        if 'dev-' in tar:
            forbidden = forbiddenInDev
        else:
            forbidden = forbiddenInAll
        tarlist = getFilenamesFromArchive(tar)
        for itemname in tarlist:
            # extra bonus check!  If we get more than one category that isn't
            # specified by the file extension, this should be added to a new
            # list above
            if '/man/' in itemname:
                print >>sys.stderr, "FORBIDDEN: Found %s in %s (manpage)" % (itemname, tar)
                bad = True
            else:
                for b in forbidden:
                    if itemname.endswith(b):
                        # Drat, another special case.  Lighttpd will not build
                        # without the pc file for libxml2.
                        if 'libxml2' in tar and b == '.pc': continue
                        print >>sys.stderr, "FORBIDDEN: Found %s in %s (%s)" % (itemname, tar, b)
                        bad = True
    return bad

def buildCheck(args):
    """Performs the buildcheck operation from the command line."""
    forbiddenInArchives(args)
    dupsInArchives(args)

################################################################################
################################################################################
def parseCommandLine():
    """Builds the command line parser and returns the arguments found."""
    # create the top-level parser
    parser = argparse.ArgumentParser(prog='archiveSearch')
    subparsers = parser.add_subparsers(help='sub-command. type "archiveSearch [subcmd] --help" for more info on each')

    # create the parser for the "find" command
    parser_find = subparsers.add_parser('find', help='search for a filename in the archives')
    parser_find.add_argument('filename', nargs='+', metavar='F', help='the name of the file to search for')
    group = parser_find.add_mutually_exclusive_group()
    group.add_argument('-a', '--archive', action='append', metavar='A', help='the name(s) of the archive(s) in which to search')
    group.add_argument('-d', '--directory', action='append', metavar='D', help='the directory containing all archives to search')
    parser_find.set_defaults(func=findInArchives)

    # create the parser for the "dups" command
    parser_dups = subparsers.add_parser('dups', help='find duplicates in a set of archives')
    parser_dups.add_argument('directories', nargs='+', metavar='DIR', help='the directories containing the archives')
    parser_dups.set_defaults(func=dupsInArchives)

    # create the parser for the "list" command
    parser_find = subparsers.add_parser('list', help='list the contents of an archive or directory of archives')
    group = parser_find.add_mutually_exclusive_group()
    group.add_argument('-a', '--archive', action='append', metavar='A', help='the name(s) of the archive(s) to list')
    group.add_argument('-d', '--directory', action='append', metavar='D', help='the directory containing all archives to list')
    parser_find.set_defaults(func=listArchives)

    # create the parser for the "bad" command
    parser_dups = subparsers.add_parser('bad', help='search for forbidden files in a set of archives')
    parser_dups.add_argument('directories', nargs='+', metavar='DIR', help='the directories containing the archives')
    parser_dups.set_defaults(func=forbiddenInArchives)

    # create the parser for the "buildcheck" command
    parser_dups = subparsers.add_parser('buildcheck', help='run both bad and dup check commands - for end of build process')
    parser_dups.add_argument('directories', nargs='+', metavar='DIR', help='the directories containing the archives')
    parser_dups.set_defaults(func=buildCheck)

    # parse the args
    args = parser.parse_args()

    return args

def archiveSearch():
    """Main routine for this script."""
    args = parseCommandLine()

    # call the function specified by the command line args
    if args.func(args):
        # set non-zero exit code if True return value
        return 1
    return 0

if __name__ == '__main__':
    exit(archiveSearch())
